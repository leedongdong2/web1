오라클
alter session set “_ORACLE_SCRIPT” =true
12이전버젼 생성
유저명 앞에 c##을 안써도 된다
유저생성;
sql>create user 유저명 identified by 암호
유저삭제 ; 
sql> drop user 유저명;

오라클 연결해제:
sql> disconn;
연결: 
conn;       localhost = 127.0.0.1

admin(sys):암호를 잊어버렷을떄 원격지에선 안되고 로컬에서만 된다
sql> sys as sysdba
암호변경
sql> alter user sys identified by 1111

                (모든컬럼)
SELECT             *                         FROM      EMPLOYEES                 E;
(조회)    (조회되기를원하는것)        (테이블명)    (테이블명의 별칭)(Alias)옵션
            (보안과 성능상 현업에선     or(서브쿼리)
           거의 사용 x )                            

dual :오라클 제공 테스트용 가상테이블 컴럼1 로우1

숫자이외에는  작은따옴표 사용(문자는 대소문자를 구분,날짜는 대소문자 구분x) 별칭은 큰따옴표로 사용

      a<b                    a>b
a는 b보다 작다      a는 b보다 크다
왼쪽기준으로 생각한다

집합연산자

포인트 - 컬럼수가 같고 컬럼속성이 같아야함 컬럼이름은 달라도됨
(서로다른 지역에 있는 테이블을 합쳐서 하나로 만드는거로 생각하면됨)
(부산지사의 직원들 명단과 제주명단의 직원들 명단을 합친다) 

union : 두집합의결과를 합쳐서 출력 중복값제거 정렬
union all : 두집합의 결과를 합쳐서 출력 중복값도 허용하고 정렬 안함
intersect :  교집합 결과를 출력 및 정렬
minus : 차집합 결과를 출력 및 정렬함 쿼리의 순서 중요.

ceil     x (1<x<=2) =  x=2 절상    (음수,양수) 더큰수로 간다
floor   x(2<=x<3) x = 2  절하  (음수,양수) 더 작은수로 간다
둘다 본인과 완벽히 동일하면 본인이 됨

decode 는 같다정도만(=) 사용가능하다(비교적 쉽다)
decode(a,b,1,2) a가 b라면 1을 출력 아니면 2를출력

대신 case를 이용하여 크다 작다등의 자세한 비교가 가능하다(어렵다)
패턴 1  (범위는 사용불가 decode랑 유사)
case 조건  
when 결과1 then 출력 1
  [when 결과2 then 출력 2
   .....
   else 기타출력 
  ] 
end "컬럼명"

패턴 2 (범위사용가능 if문가 유사)
case  
when 조건1 then 출력 1
  [when 조건2 then 출력 2
   .....
   else 기타출력 
  ] 
end "컬럼명"

GROUP BY절 
~~별(GROUP) 집계 를 구할떄 쓴다

--그룹바이절 사용시 유의사항
--1) SELECT절에는 GROUP BY절에 사용한 컬럼명만 사용가능 (별칭사용불가능)
--2) 만약 GROUP BY절에서 사용한 컬럼명이 아닌 경우엔 반드시 집계합수내에서 사용해야함


GROUP BY를 쓸때 WHERE절과 HAVING 절의 차이
WHERE 은 WHERE조건에따라(필터를 한후에) 그룹을 묻는것이고
HAVING 은 그룹을 먼저 다 한후에 그룹에서 조건을 거는것이다
또한 WHERE은 집단함수로는 조건을 걸수 없고
HAVING 절은 집단함수를 사용하여 그룹내에서 조건을 걸수 있다

[정규화] => 비정규화가 최종 목적이다.
- 비정규화란?
 필요에 따라서 테이블이 쪼개진 상태인데,성능,사용성등의 요인으로 다시 두개이상의 테이블이 다시 하나로 합쳐지는 상태

- 정규화 : 중복데이터를 배제,NULL 값 배제,정리하는것

>DML(insert,update,delete,merge)
>DQL(select)
>DDL(create,truncate,drop,alter)
>DCL(grant,revoke)
>TCL(commit,rollback)트랜잭션

>테이블 생성 및 구조 변경(DDL)
>데이터 입력 수정(DML)
>제약조건(PK,FK,NOT NULL,CHECK, UNIQUE)

제약조건의 비활성화/ 활성화 
              NOVALIDATE            |    VALIDATE
DISABLE  제약조건 비활성(기본)   |  데이터 수정 불가
------------------------------------ |--------------------------------
ENABLE   기존데이터 체크X        |  기존데이터 체크 (기본)       
                                          |


INDEX

목적 : 검색을 보다 빠르게 하기위해.
PRIMARY KEY,UNIQUE 속성을  갖는 컬럼에는 자동으로 INDEX 처리됨.

인덱스의 사용 조건
1) 테이블의 행수가 많을 경우
2) WHERE 절에 많이 사용되는 컬럼
3) JOIN에 자주 사용되는 컬럼.
4) NULL을 포함하는 컬럼이 많은 경우.

INDEX 사용 비추
1) 행수가 적은 경우
2) 검색결과가 10~15%이상인 경우
3) DML이 자주 일어나는 경우(INSERT,UPDATE,DELETE)

[index의 종류]
1) 고유 index(unique index):유일한 값을 갖는 컬럼에 index를 생성하는 경우
2) 비고유 index(non unique index):
3) 단일 index(single index):하나의 컬럼을 사용하여 index를 생성하는 경우
4) 결합 index(composite index) : 두개이상의 컬럼을 사용하여 index를 생성하는 경우
5) 함수 index(function based index) :  검색이 되는 컬럼에 연산식이 포함되는 경우 

[index 생성 방법]
----싱글 인덱스--------------
1) create unique index 인덱스명 on 테이블명(컬럼명) 중복 x
2) create index 인덱스명 on 테이블명(컬럼명)
---결합인덱스------------------
3) create index 인덱스명 on  테이블명(컬럼명1,컬럼명2)
----함수 인덱스-----------------------------------
4) create index 인덱스명 on 테이블명(salary*100);
                                                   함수
 
[index 제거]
drop index 인덱스명

[index 재구성] : DML이 빈번하게 수행되는 경우
ALTER INDEX 인덱스명 REBUILD


-----------------------------------------------------------------------------
[서브쿼리 다중연산자]  ANY = OR 연산,ALL = AND 연산
IN = 다중값이나올때
                                 <  or  <  or <
K > ANY (10,20,30)   0     10     20     30   any  는 최소값을 반환
k > ANY (10,20,30) = K 는 (10보다 크면된다) 

                                  > or   > or  >
K < ANY (10,20,30)   0     10      20     30  any 는 최대값을 반환
k < ANY (10,20,30) = K 는  (30보다 작으면된다)

                                  > and > and >
k < ALL  (10,20,30)    0     10      20    30  ALL 은 최소값을 반환
k < ALL  (10,20,30) = K 는 (10보다 작으면 된다)

                                   < and < and<
k > ALL  (10,20,30)    0     10      20    30  ALL 은 최대값 반환
k > ALL  (10,20,30) = K 는 (30 보다 크면된다)

-------------------------------------------------------------------------------
SEQUENCE(일련번호)

----------------------------------------------------------------------------------

계층형 쿼리와 페이징 

3중 셀렉트 쿼리

(메인)계층형 쿼리작업(선택,조건) → 순서를 지정 → 페이징처리

----------------------------------------------------------------------------------
PL-SQL
변수의 유형
1) 스칼라형 : 오라클의 기본 데이터 유형(vachar,number,char....)
2) %TYPE : 하나의 컬럼 유형을 가져옴.
3) %ROWTYPE : 행 전체의 유형을 가져옴.
4) RECORD : %ROWTYPE과 유사하나 변수의 요소를 임의로 추가, 삭제할 수 있음
5) TABLE : 하나의 배열과 유사하다
------------------------------------------------------------------------------------

view
--- 내가 자주 보는 select문의 테이블을 가상의 테이블로 저장

프로시져(반환값없음)  & function(반환값있음) 
---- 자주쓰는 select문이나 명령어를 함수로 따로 저장해서 사용
---- 또한 다른 랭귀지에서 사용할수 있다.

트리거(방아쇠)
--- a라는 사건을 발생시키면 자동으로 b를 실행시키는형태
--- 아니면 입력값을 지정해놓아 잘못 입력된 값이 내가 지정한 입력값으로 자동으로 변환되어
입력하게 해준다                                             

